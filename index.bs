<pre class='metadata'>
Title: WebRTC Encoded Transform
Shortname: webrtc-encoded-transform
Level: None
Status: ED
Group: webrtc
TR: https://www.w3.org/TR/webrtc-encoded-transform/
Repository: w3c/webrtc-encoded-transform
URL: https://w3c.github.io/webrtc-encoded-transform/
Editor: Harald Alvestrand, w3cid 24610 , Google https://google.com, hta@google.com
Editor: Guido Urdaneta, w3cid 84810, Google https://google.com, guidou@google.com
Editor: Youenn Fablet, w3cid 96458, Apple https://www.apple.com, youenn@apple.com
Abstract: This API defines an API surface for manipulating the bits on
Abstract: {{MediaStreamTrack}}s being sent via an {{RTCPeerConnection}}.
Markup Shorthands: css no, markdown yes
</pre>
<pre class=link-defaults>
spec:webidl; type:dfn; text:resolve
</pre>
<pre class=biblio>
{
   "VP9": {
    "href":
    "https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.6-20160331-draft.pdf",
    "title": "VP9 Bitstream & Decoding Process Specification",
    "publisher": "The WebM Project"
   },
   "ITU-T-REC-H.264": {
    "href": "https://www.itu.int/rec/T-REC-H.264",
    "title": "H.264 : Advanced video coding for generic audiovisual services",
    "publisher": "ITU"
   },
   "ITU-G.711": {
    "href": "https://www.itu.int/rec/T-REC-G.711/",
    "title": "G.711 : Pulse code modulation (PCM) of voice frequencies",
    "publisher": "ITU"
   },
   "ITU-G.722": {
    "href": "https://www.itu.int/rec/T-REC-G.722/",
    "title": "G.722 : 7 kHz audio-coding within 64 kbit/s",
    "publisher": "ITU"
   },
   "CloneArrayBuffer": {
    "href": "https://tc39.es/ecma262/#sec-clonearraybuffer",
    "title": "CloneArrayBuffer"
   },
   "RTP-EXT-CAPTURE-TIME": {
    "href": "https://datatracker.ietf.org/doc/draft-ietf-avtcore-abs-capture-time/",
    "title": "RTP Header Extension for Absolute Capture Time",
    "publisher": "IETF"
   }
}
</pre>
<pre class=link-defaults>
spec:streams; type:interface; text:ReadableStream
spec:infra; type:dfn; text:list
</pre>

# Introduction # {#introduction}

The [[WEBRTC-NV-USE-CASES]] document describes the use-case of
    * Untrusted JavaScript Cloud Conferencing
which requires that the conferencing server does not have access
to the cleartext media (requirement N27).

This specification provides access to encoded media,
which is the output of the encoder part of a codec and the input to the
decoder part of a codec which allows the user agent to apply encryption
locally.

The interface is inspired by [[WEBCODECS]] to
provide access to such functionality while retaining the setup flow of
RTCPeerConnection

# Specification # {#specification}

The Streams definition doesn't use WebIDL much, but the WebRTC spec does.
This specification shows the IDL extensions for WebRTC.

It uses an additional API on {{RTCRtpSender}} and {{RTCRtpReceiver}} to
insert the processing into the pipeline.

<pre class="idl">
typedef (SFrameTransform or RTCRtpScriptTransform) RTCRtpTransform;

// New methods for RTCRtpSender and RTCRtpReceiver
partial interface RTCRtpSender {
    attribute RTCRtpTransform? transform;
};

partial interface RTCRtpReceiver {
    attribute RTCRtpTransform? transform;
};
</pre>

This API allows manipulation of <dfn>encoded frames</dfn> in the media
pipeline between the processing steps of an {{RTCRtpSender}}'s
underlying <dfn>encoder</dfn> and <dfn>packetizer</dfn>, and/or
between an {{RTCRtpReceiver}}'s underlying <dfn>depacketizer</dfn>
and <dfn>decoder</dfn>.

The [=encoder=] and [=depacketizer=] each have a
<dfn>[[processedFramesQueue]]</dfn> internal slot initialized to
an empty [=queue=], and a
<dfn>[[transformFrameAlgorithm]]</dfn> internal slot initialized to
the <dfn>passthrough algorithm</dfn> which, given an [=encoded frame=]
|frame|, is to return |frame|.

Whenever the [=encoder=] outputs an [=encoded frame=], the user
agent MUST invoke the [=encoder=].[=[[transformFrameAlgorithm]]=] on
it and pass the result to the associated [=packetizer=] in place of
the original frame.

Whenever the [=depacketizer=] outputs an [=encoded frame=], the
user agent MUST invoke the [=depacketizer=].[=[[transformFrameAlgorithm]]=]
on it and pass the result to the associated [=decoder=] in place of
the original frame.

## Extension operation ## {#operation}

At construction of each {{RTCRtpSender}} or {{RTCRtpReceiver}}, run the following steps:
1. Initialize [=this=].`[[transform]]` to null.
1. Initialize [=this=].`[[pipeToController]]` to null.
1. Initialize [=this=].`[[frameSource]]` to [=this=]'s [=encoder=] if [=this=] is an {{RTCRtpSender}} or [=this=]'s [=depacketizer=] otherwise.

### Stream processing ### {#stream-processing}

<p class=note>
Streams backpressure can optimize throughput while limiting processing and memory consumption by pausing data production as early as possible in a data pipeline.
This proves useful in contexts where reliability is essential and latency is less of a concern.
On the other hand, WebRTC media pipelines favour low latency over reliability, for instance by allowing to drop frames at various places and by using recovery mechanisms.
Buffering within a transform would add latency without allowing web applications to adapt much.
The User Agent is responsible for doing these adaptations, especially since it controls both ends of the transform.
For those reasons, streams backpressure is disabled in WebRTC encoded transforms.
</p>

The <dfn abstract-op>readEncodedData</dfn> algorithm is given an {{RTCRtpScriptTransformer}}
|transformer| as parameter, and |frame| as input. It is defined by running the following steps:
1. Set |frame|.`[[owner]]` to |transformer|.{{[[frameSource]]}}.
1. Set |frame|.`[[counter]]` to |transformer|.{{[[lastEnqueuedFrameCounter]]}}.
1. If |frame|.`[[owner]]` is a [=depacketizer=]:
    1. If the relevant RTP packet contains the
        [[RTP-EXT-CAPTURE-TIME|RTP Header Extension for Absolute Capture Time]], set |frame|.`[[captureTime]]` to the
        [[RTP-EXT-CAPTURE-TIME#absolute-capture-timestamp|absolute capture timestamp]] field and set |frame|.`[[senderCaptureTimeOffset]]`
        to the [[RTP-EXT-CAPTURE-TIME#estimated-capture-clock-offset|capture clock offset field]] if it is present.
    1. Otherwise, if the relevant RTP packet does not contain the
        [[RTP-EXT-CAPTURE-TIME|RTP Header Extension for Absolute Capture Time]] but a previous RTP packet did,
        set |frame|.`[[captureTime]]` to the result of calculating the absolute capture timestamp according to
        [[RTP-EXT-CAPTURE-TIME#timestamp-interpolation|timestamp interpolation]] and set |frame|.`[[senderCaptureTimeOffset]]`
        to the most recent value that was present.
    1. Otherwise, set |frame|.`[[captureTime]]` to undefined and set |frame|.`[[senderCaptureTimeOffset]]` to undefined.
1. If |frame|.`[[owner]]` is an [=encoder=], set |frame|.`[[captureTime]]` to the capture timestamp
    using the methodology described in [[RTP-EXT-CAPTURE-TIME#absolute-capture-timestamp]] and set frame.`[[senderCaptureTimeOffset]]`
    to undefined.
1. [=ReadableStream/Enqueue=] |frame| into |transformer|.{{[[readable]]}}.

The <dfn abstract-op>writeEncodedData</dfn> algorithm is given an {{RTCRtpScriptTransformer}}
|transformer| as parameter and a |frame| as input. It is defined by running the following steps:
1. If |frame|.`[[owner]]` is not equal to |transformer|.{{[[frameSource]]}}, abort these steps and return [=a promise resolved with=] undefined. A processor cannot create frames, or move frames between streams.
1. If |frame|.`[[counter]]` is equal or smaller than |transformer|.`[[lastReceivedFrameCounter]]`, abort these steps and return [=a promise resolved with=] undefined. A processor cannot reorder frames, although it may delay them or drop them.
1. Set |transformer|.`[[lastReceivedFrameCounter]]` to |frame|.`[[counter]]`.
1. Let |data| be |frame|.`[[data]]`.
1. Let |serializedFrame| be [$StructuredSerializeWithTransfer$](|frame|, « |data| »).
1. Let |frameCopy| be [$StructuredDeserializeWithTransfer$](|serializedFrame|, |frame|'s [=relevant realm=]).
1. Let |processedFrame| be |frameCopy|'s underlying [=encoded frame=].
1. [=In parallel=], [=queue/enqueue=] |processedFrame| onto |transformer|.{{[[frameSource]]}}.[=[[processedFramesQueue]]=].
1. Return [=a promise resolved with=] undefined.

On the sender side, as part of [$readEncodedData$], frames produced by the [=encoder=] MUST be [=ReadableStream/enqueued=] into |transformer|.{{[[readable]]}} in the [=encoder=]'s output order.
As [$writeEncodedData$] ensures that the transform cannot reorder frames, the encoder's output order is also the order followed by packetizers to generate RTP packets and assign RTP packet sequence numbers.
The [=packetizer=] may expect the transformed data to still conform to the original format, e.g. a series of NAL units separated by Annex B start codes.

On the receiver side, as part of [$readEncodedData$], frames produced by the [=depacketizer=] MUST be [=ReadableStream/enqueued=] into |transformer|.{{[[readable]]}} in the same [=encoder=]'s output order.
To ensure the order is respected, the [=depacketizer=] will typically use RTP packet sequence numbers to reorder RTP packets as needed before [=ReadableStream/enqueuing=] frames into |transformer|.{{[[readable]]}}.
As [$writeEncodedData$] ensures that the transform cannot reorder frames, this will be the order expected by the [=decoder=].

### RTCRtpTransform common processing ### {#transform-processing}

An RTCRtpTransform has a private slot:
* `[[owner]]` of type {{RTCRtpSender}} or {{RTCRtpReceiver}}, initialized to null.

Each RTCRtpTransform has an <dfn abstract-op for=RTCRtpTransform>association algorithm</dfn>
and a <dfn abstract-op for=RTCRtpTransform>disassociation algorithm</dfn>, both empty by default.

## Extension attribute ## {#attribute}

The <dfn attribute for="RTCRtpSender,RTCRtpReceiver">transform</dfn> getter steps are to
return [=this=].`[[transform]]`. The setter steps are:
1. Let |transform| be the argument to the setter.
1. If |transform| is not null and |transform|.`[[owner]]` is not null, throw a {{InvalidStateError}} and abort these steps.
1. Set |transform|.`[[owner]]` to [=this=].
1. Let |oldTransform| be [=this=].`[[transform]]`.
1. If |oldTransform| is not null, run |oldTransform|'s [$disassociation algorithm$].
1. Set [=this=].`[[transform]]` to |transform|.
1. If |transform| is not null, run |transform|'s [$association algorithm$] with [=this=].
1. If |transform| is null, run the following steps:
    1. Let |frameSource| be [=this=].`[[frameSource]]`.
    1. [=In parallel=], set |frameSource|.[=[[transformFrameAlgorithm]]=] to the [=passthrough algorithm=].

This algorithm is defined so that transforms can be updated dynamically.
There is no guarantee on which frame will happen the switch from the previous transform to the new transform.

If a web application sets the transform synchronously at creation of the {{RTCRtpSender}} (for instance when calling addTrack), the transform will receive the first frame generated by the {{RTCRtpSender}}'s encoder.
Similarly, if a web application sets the transform synchronously at creation of the {{RTCRtpReceiver}} (for instance when calling addTrack, or at track event handler), the transform will receive the first full frame generated by the {{RTCRtpReceiver}}'s packetizer.

# SFrameTransform # {#sframe}

<p>
The APIs presented in this section allow applications to process SFrame data using specific cipher suites defined in [[RFC9605]].
</p>

<xmp class="idl">
// List of supported cipher suites, as defined in [[RFC9605]] section 4.5.
enum SFrameCipherSuite {
     "AES_128_CTR_HMAC_SHA256_80",
     "AES_128_CTR_HMAC_SHA256_64",
     "AES_128_CTR_HMAC_SHA256_32",
     "AES_128_GCM_SHA256_128",
     "AES_256_GCM_SHA512_128"
};

dictionary SFrameTransformOptions {
    required SFrameCipherSuite cipherSuite;
};

typedef [EnforceRange] unsigned long long SmallCryptoKeyID;
typedef (SmallCryptoKeyID or bigint) CryptoKeyID;

interface mixin SFrameKeyManagement {
    Promise<undefined> setEncryptionKey(CryptoKey key, optional CryptoKeyID keyID);
    attribute EventHandler onerror;
};

[Exposed=Window]
interface SFrameTransform : EventTarget {
    constructor(optional SFrameTransformOptions options = {});
};
SFrameTransform includes SFrameKeyManagement;

[Exposed=(Window,DedicatedWorker)]
interface SFrameEncrypterStream : EventTarget {
    constructor(optional SFrameTransformOptions options = {});
};
SFrameEncrypterStream includes GenericTransformStream;
SFrameEncrypterStream includes SFrameKeyManagement;

[Exposed=(Window,DedicatedWorker)]
interface SFrameDecrypterStream : EventTarget {
    constructor(optional SFrameTransformOptions options = {});
};
SFrameDecrypterStream includes GenericTransformStream;
SFrameDecrypterStream includes SFrameKeyManagement;

enum SFrameTransformErrorEventType {
    "authentication",
    "keyID",
    "syntax"
};

[Exposed=(Window,DedicatedWorker)]
interface SFrameTransformErrorEvent : Event {
    constructor(DOMString type, SFrameTransformErrorEventInit eventInitDict);

    readonly attribute SFrameTransformErrorEventType errorType;
    readonly attribute CryptoKeyID? keyID;
    readonly attribute any frame;
};

dictionary SFrameTransformErrorEventInit : EventInit {
    required SFrameTransformErrorEventType errorType;
    required any frame;
    CryptoKeyID? keyID;
};
</xmp>

The <dfn constructor for="SFrameTransform" lt="SFrameTransform(options)"><code>new SFrameTransform(<var>options</var>)</code></dfn> constructor steps are:
1. Let |options| be the method's first argument.
1. Run the [=SFrame initialization algorithm=] with |this| and |options|.

The <dfn constructor for="SFrameEncrypterStream" lt="SFrameEncrypterStream(options)"><code>new SFrameEncrypterStream(<var>options</var>)</code></dfn> constructor steps are:
1. Let |options| be the method's first argument.
1. Run the [=SFrame initialization algorithm=] with |this| and |options|.
1. Set |this|.`[[role]]` to 'encrypt'.

The <dfn constructor for="SFrameDecrypterStream" lt="SFrameDecrypterStream(options)"><code>new SFrameDecrypterStream(<var>options</var>)</code></dfn> constructor steps are:
1. Let |options| be the method's first argument.
1. Run the [=SFrame initialization algorithm=] with |this| and |options|.
1. Set |this|.`[[role]]` to 'decrypt'.

## Algorithms ## {#sframe-algorithms}

The <dfn>SFrame initialization algorithm</dfn>, given |this| and |options|, runs these steps:
1. Let |transformAlgorithm| be an algorithm which takes a |frame| as input and runs the [=SFrame transform algorithm=] with |this| and |frame|.
1. Set |this|.`[[transform]]` to a new {{TransformStream}}.
1. <a dfn for="ReadableStream">Set up</a> [=this=].`[[transform]]` with [=TransformStream/set up/transformAlgorithm=] set to |transformAlgorithm|.
1. Set |this|.`[[cipherSuite]]` to |options|["{{SFrameTransformOptions/cipherSuite}}"].
1. Set |this|.`[[readable]]` to |this|.`[[transform]]`.`[[readable]]`.
1. Set |this|.`[[writable]]` to |this|.`[[transform]]`.`[[writable]]`.

The <dfn>SFrame transform algorithm</dfn>, given |this| and |frame|, runs these steps:
1. Let |role| be |this|.`[[role]]`.
1. If |this|.`[[owner]]` is an {{RTCRtpSender}}, set |role| to 'encrypt'.
1. If |this|.`[[owner]]` is an {{RTCRtpReceiver}}, set |role| to 'decrypt'.
1. Let |data| be undefined.
1. If |frame| is a {{BufferSource}}, set |data| to |frame|.
1. If |frame| is a {{RTCEncodedAudioFrame}}, set |data| to |frame|.{{RTCEncodedAudioFrame/data}}
1. If |frame| is a {{RTCEncodedVideoFrame}}, set |data| to |frame|.{{RTCEncodedVideoFrame/data}}
1. If |data| is undefined, abort these steps.
1. Let |buffer| be the result of running the SFrame algorithm with |data|, |this|.`[[cipherSuite]]`, and |role| as parameters. This algorithm is defined by [[RFC9605]] and returns an {{ArrayBuffer}}.
1. If the SFrame algorithm exits abruptly with an error, [=queue a task=] to run the following sub steps:
     1. If the processing fails on decryption side due to |data| not following the SFrame format, [=fire an event=] named {{SFrameKeyManagement/onerror|error}} at |this|,
        using the {{SFrameTransformErrorEvent}} interface with its {{SFrameTransformErrorEvent/errorType}} attribute set to {{SFrameTransformErrorEventType/syntax}}
        and its {{SFrameTransformErrorEvent/frame}} attribute set to |frame|.
     1. If the processing fails on decryption side due to the key identifier parsed in |data| being unknown, [=fire an event=] named {{SFrameKeyManagement/onerror|error}} at |this|,
        using the {{SFrameTransformErrorEvent}} interface with its {{SFrameTransformErrorEvent/errorType}} attribute set to {{SFrameTransformErrorEventType/keyID}},
        its {{SFrameTransformErrorEvent/frame}} attribute set to |frame| and its {{SFrameTransformErrorEvent/keyID}} attribute set to the keyID value parsed in the SFrame header.
     1. If the processing fails on decryption side due to validation of the authentication tag, [=fire an event=] named {{SFrameKeyManagement/onerror|error}} at |this|,
        using the {{SFrameTransformErrorEvent}} interface with its {{SFrameTransformErrorEvent/errorType}} attribute set to {{SFrameTransformErrorEventType/authentication}}
        and its {{SFrameTransformErrorEvent/frame}} attribute set to |frame|.
     1. Abort these steps.
1. If |frame| is a {{BufferSource}}, set |frame| to |buffer|.
1. If |frame| is a {{RTCEncodedAudioFrame}}, set |frame|.{{RTCEncodedAudioFrame/data}} to |buffer|.
1. If |frame| is a {{RTCEncodedVideoFrame}}, set |frame|.{{RTCEncodedVideoFrame/data}} to |buffer|.
1. [=ReadableStream/Enqueue=] |frame| in |this|.`[[transform]]`.

## Methods ## {#sframe-transform-methods}
The <dfn method for="SFrameTransform">setEncryptionKey(|key|, |keyID|)</dfn> method steps are:
1. Let |promise| be [=a new promise=].
2. If |keyID| is a {{bigint}} which cannot be represented as a integer between 0 and 2<sup>64</sup>-1 inclusive, [=reject=] |promise| with a {{RangeError}} exception.
3. Otherwise, [=in parallel=], run the following steps:
    1. Set |key| with its optional |keyID| as key material to use for the SFrame transform algorithm, as defined by [[RFC9605]].
    2. If setting the key material fails, [=reject=] |promise| with an {{InvalidModificationError}} exception and abort these steps.
    3. [=Resolve=] |promise| with undefined.
4. Return |promise|.


# Script Transform # {#scriptTransform}

In this section, the capture system refers to the system where media is sourced from and the sender system
refers to the system that is sending RTP and RTCP packets to the receiver system where {{RTCEncodedFrameMetadata}} data is populated.

## <dfn dictionary>RTCEncodedFrameMetadata</dfn> dictionary ## {#RTCEncodedFrameMetadata}
<pre class="idl">
dictionary RTCEncodedFrameMetadata {
    unsigned long synchronizationSource;
    octet payloadType;
    sequence&lt;unsigned long&gt; contributingSources;
    unsigned long rtpTimestamp;
    DOMHighResTimeStamp receiveTime;
    DOMHighResTimeStamp captureTime;
    DOMHighResTimeStamp senderCaptureTimeOffset;
    DOMString mimeType;
};
</pre>

### Members ### {#RTCEncodedFrameMetadata-members}

<dl dfn-for="RTCEncodedFrameMetadata" class="dictionary-members">
    <dt>
        <dfn dict-member>synchronizationSource</dfn> <span class="idlMemberType">unsigned long</span>
    </dt>
    <dd>
        <p>
            The synchronization source (ssrc) identifier is an unsigned integer value per [[RFC3550]]
            used to identify the stream of RTP packets that the encoded frame object is describing.
        </p>
    </dd>
    <dt>
        <dfn dict-member>payloadType</dfn> <span class="idlMemberType">octet</span>
    </dt>
    <dd>
        <p>
            The payload type is an unsigned integer value in the range from 0 to 127 per [[RFC3550]]
            that is used to describe the format of the RTP payload.
        </p>
    </dd>
    <dt>
        <dfn dict-member>contributingSources</dfn> <span class=
            "idlMemberType">sequence&lt;unsigned long&gt;</span>
    </dt>
    <dd>
        <p>
            The list of contribution sources (csrc list) as defined in [[RFC3550]].
        </p>
    </dd>
    <dt>
        <dfn dict-member>rtpTimestamp</dfn> <span class=
            "idlMemberType">unsigned long</span>
    </dt>
    <dd>
        <p>
            The RTP timestamp identifier is an unsigned integer value per [[RFC3550]]
            that reflects the sampling instant of the first octet in the RTP data packet.
        </p>
    </dd>
    <dt>
        <dfn dict-member>receiveTime</dfn> <span class=
            "idlMemberType">DOMHighResTimeStamp</span>
    </dt>
    <dd>
        <p>
            For frames coming from an RTCRtpReceiver, represents the timestamp
            of the last received packet used to produce this media frame. This
            timestamp is relative to {{Performance}}.{{Performance/timeOrigin}}.
        </p>
    </dd>
    <dt>
        <dfn dict-member>captureTime</dfn> <span class="idlMemberType">DOMHighResTimeStamp</span>
    </dt>
    <dd>
        <p>
            The capture time of this frame in the capture system's clock.
            On populating this member, the user agent MUST return the value of the frame's `[[captureTime]]` slot,
            shifted to be relative to {{Performance}}.{{Performance/timeOrigin}}.
        </p>
    </dd>
    <dt>
        <dfn dict-member>senderCaptureTimeOffset</dfn> <span class="idlMemberType">DOMHighResTimeStamp</span>
    </dt>
    <dd>
        <p>
            The {{RTCEncodedFrameMetadata/senderCaptureTimeOffset}} is the sender system's estimate of the offset
            between its own NTP clock and the capture system's NTP clock, for the same frame that the
            {{RTCEncodedFrameMetadata/captureTime}} was originated from.
            On populating this member, the user agent MUST return the value of the frame's `[[senderCaptureTimeOffset]]` slot.
        </p>
    </dd>
    <dt>
        <dfn dict-member>mimeType</dfn> <span class="idlMemberType">DOMString</span>
    </dt>
    <dd>
        <p>
            The codec MIME media type/subtype defined in the IANA media types registry
            [[!IANA-MEDIA-TYPES]], e.g. audio/opus or video/VP8.
        </p>
    </dd>
</dl>

## <dfn enum>RTCEncodedVideoFrameType</dfn> dictionary ## {#RTCEncodedVideoFrameType}
<pre class="idl">
// New enum for video frame types. Will eventually re-use the equivalent defined
// by WebCodecs.
enum RTCEncodedVideoFrameType {
    "empty",
    "key",
    "delta",
};
</pre>
<table dfn-for="RTCEncodedVideoFrameType" class="simple">
  <caption>Enumeration description</caption>
    <thead>
        <tr>
            <th>Enum value</th><th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <dfn enum-value>empty</dfn>
            </td>
            <td>
                <p>
                    This frame contains no data.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <dfn enum-value>key</dfn>
            </td>
            <td>
                <p>
                    This frame can be decoded without reference to any other frames.
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <dfn enum-value>delta</dfn>
            </td>
            <td>
                <p>
                    This frame references another frame and can not be decoded without that frame.
                </p>
            </td>
        </tr>
    </tbody>
</table>

## <dfn dictionary>RTCEncodedVideoFrameMetadata</dfn> dictionary ## {#RTCEncodedVideoFrameMetadata}
<pre class="idl">
dictionary RTCEncodedVideoFrameMetadata : RTCEncodedFrameMetadata {
    unsigned long long frameId;
    sequence&lt;unsigned long long&gt; dependencies;
    unsigned short width;
    unsigned short height;
    unsigned long spatialIndex;
    unsigned long temporalIndex;
    long long timestamp;    // microseconds
};
</pre>

### Members ### {#RTCEncodedVideoFrameMetadata-members}

<dl dfn-for="RTCEncodedVideoFrameMetadata" class="dictionary-members">
    <dt>
        <dfn dict-member>frameId</dfn> <span class="idlMemberType">unsigned long long</span>
    </dt>
    <dd>
        <p>
            An identifier for the encoded frame, monotonically increasing in decode order. Its lower
            16 bits match the frame_number of the AV1 Dependency Descriptor Header Extension defined in Appendix A of [[AV1-RTP-SPEC]], if present.
            Only present for received frames if the Dependency Descriptor Header Extension is present.
        </p>
    </dd>
    <dt>
        <dfn dict-member>dependencies</dfn> <span class="idlMemberType">sequence&lt;unsigned long long&gt;</span>
    </dt>
    <dd>
        <p>
            List of frameIds of frames this frame references.
            Only present for received frames if the AV1 Dependency Descriptor Header Extension defined in Appendix A of [[AV1-RTP-SPEC]] is present.
        </p>
    </dd>
    <dt>
        <dfn dict-member>timestamp</dfn> <span class=
            "idlMemberType">long long</span>
    </dt>
    <dd>
        <p>
            The media presentation timestamp (PTS) in microseconds of raw frame, matching the
            {{VideoFrame/timestamp}} for raw frames which correspond to this frame.
        </p>
    </dd>
</dl>


## <dfn interface>RTCEncodedVideoFrame</dfn> interface ## {#RTCEncodedVideoFrame-interface}
<pre class="idl">
dictionary RTCEncodedVideoFrameOptions {
    RTCEncodedVideoFrameMetadata metadata;
};

// New interfaces to define encoded video and audio frames. Will eventually
// re-use or extend the equivalent defined in WebCodecs.
[Exposed=(Window,DedicatedWorker), Serializable]
interface RTCEncodedVideoFrame {
    constructor(RTCEncodedVideoFrame originalFrame, optional RTCEncodedVideoFrameOptions options = {});
    readonly attribute RTCEncodedVideoFrameType type;
    attribute ArrayBuffer data;
    RTCEncodedVideoFrameMetadata getMetadata();
};
</pre>

### Constructor ### {#RTCEncodedVideoFrame-constructor}
<dl dfn-for="RTCEncodedVideoFrame" class="dictionary-members">
    <dt>
        <dfn for="RTCEncodedVideoFrame" method>constructor()</dfn>
    </dt>
    <dd>
        <p>
            Creates a new {{RTCEncodedVideoFrame}} from the given |originalFrame| and
            |options|.`[metadata]`. The newly created frame is completely independent of
            |originalFrame|, with its `[[data]]` being a deep copy of |originalFrame|.`[[data]]`.
            The new frame's `[[metadata]]` is a deep copy of |originalFrame|.`[[metadata]]`, with
            fields replaced with deep copies of the fields present in |options|.`[metadata]`.

            When called, run the following steps:

            1. Set this.`[[type]]` to |originalFrame|.`[[type]]`.
            1. Let this.`[[data]]` be the result of [[CloneArrayBuffer]](|originalFrame|.`[[data]]`, 0, |originalFrame|.`[[data]]`.`[[ArrayBufferByteLength]]`).
            1. Let `[[metadata]]` represent the metadata associated with this newly constructed frame.
                1. For each {`[[key]]`,`[[value]]`} pair of |originalFrame|.`[[getMetadata()]]`, set `[[metadata]]`.`[[key]]` to a deep copy of `[[value]]`.
                1. For each {`[[key]]`,`[[value]]`} pair of |options|.`[metadata]`, set `[[metadata]]`.`[[key]]` to a deep copy of `[[value]]`.

        </p>
    </dd>
</dl>

### Members ### {#RTCEncodedVideoFrame-members}
<dl dfn-for="RTCEncodedVideoFrame" class="dictionary-members">
    <dt>
        <dfn attribute>type</dfn> <span class="idlMemberType">RTCEncodedVideoFrameType</span>
    </dt>
    <dd>
        <p>
            The type attribute allows the application to determine when a frame is a key frame or a delta frame.
            On getting, |this|.`[[type]]` MUST be returned.
        </p>
    </dd>
    <dt>
        <dfn attribute>data</dfn> <span class="idlMemberType">ArrayBuffer</span>
    </dt>
    <dd>
        <p>
            The encoded frame data. The format of the data depends on the video codec that is
            used to encode/decode the frame which can be determined by looking at the
            {{RTCEncodedFrameMetadata/mimeType}}.
            For <a href="https://w3c.github.io/webrtc-svc/">SVC</a>, each spatial layer
            is transformed separately.
            On getting, |this|.`[[data]]` MUST be returned. On setting, |this|.`[[data]]` MUST be set to the new value.
        </p>
        <p class="note">
              Since packetizers may drop certain elements, e.g. AV1 temporal delimiter OBUs,
              the input to a receive-side transform may be different from the output of
              a send-side transform.
        </p>
        <p>
            The following table gives a number of examples:
        </p>
        <table class="simple">
            <thead>
                <tr>
                    <th>mimeType</th><th>Data format</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        video/VP8
                    </td>
                    <td>
                        The data starts with the "uncompressed data chunk" defined in
                        <a href="https://datatracker.ietf.org/doc/html/rfc6386#section-9.1">
                        section 9.1</a> of [[RFC6386]] and is followed by the rest of the
                        frame data. The <a href="https://www.rfc-editor.org/rfc/rfc7741#section-4.1">
                        VP8 payload descriptor</a> is not accessible.
                    </td>
                </tr>
                <tr>
                    <td>
                        video/VP9
                    </td>
                    <td>
                        The data is a frame as described in Section 6 of [[VP9]].
                        The <a href="https://datatracker.ietf.org/doc/html/draft-ietf-payload-vp9#section-4.2">
                        VP9 payload descriptor</a> is not accessible.
                    </td>
                </tr>
                <tr>
                    <td>
                        video/H264
                    </td>
                    <td>
                        The data is a series of NAL units in Annex B format,
                        as defined in [[ITU-T-REC-H.264]] Annex B.
                    </td>
                </tr>
                <tr>
                    <td>
                        video/AV1
                    </td>
                    <td>
                        The data is a series of OBUs compliant to the
                        <a href="https://aomediacodec.github.io/av1-spec/#low-overhead-bitstream-format">
                        low-overhead bitstream format</a> as described in Section 5 of [[AV1]].
                        The <a href="https://aomediacodec.github.io/av1-rtp-spec/#aggregation-header">
                        AV1 aggregation header</a> is not accessible.
                    </td>
                </tr>
            </tbody>
        </table>
    </dd>
</dl>

### Methods ### {#RTCEncodedVideoFrame-methods}
<dl dfn-for="RTCEncodedVideoFrame" class="dictionary-members">
    <dt>
        <dfn for="RTCEncodedVideoFrame" method>getMetadata()</dfn>
    </dt>
    <dd>
        <p>
            Returns the metadata associated with the frame.
        </p>
    </dd>
</dl>

### Serialization ### {#RTCEncodedVideoFrame-serialization}

{{RTCEncodedVideoFrame}} objects are [=serializable objects=].
Their [=serialization steps=], given |value|, |serialized|, and |forStorage|, are:

1. If |forStorage| is true, then throw a {{DataCloneError}}.
1. Set |serialized|.`[[type]]` to the value of |value|.`[[type]]`.
1. Set |serialized|.`[[metadata]]` to an internal representation of |value|'s metadata.
1. Set |serialized|.`[[data]]` to the [=sub-serialization=] of |value|.`[[data]]`.


Their [=deserialization steps=], given |serialized|, |value| and |realm|, are:

1. Set |value|.`[[type]]` to |serialized|.`[[type]]`.
1. Set |value|'s metadata to the platform object representation of |serialized|.`[[metadata]]`.
1. Set |value|.`[[data]]` to the [=sub-deserialization=] of |serialized|.`[[data]]`.

<p class="note">
The internal form of a serialized RTCEncodedVideoFrame is not observable;
it is defined chiefly so that it can be used with frame cloning in the
[$writeEncodedData$] algorithm and in the {{WindowOrWorkerGlobalScope/structuredClone()}} operation.
An implementation is therefore free to choose whatever method works best.
</p>

## <dfn dictionary>RTCEncodedAudioFrameMetadata</dfn> dictionary ## {#RTCEncodedAudioFrameMetadata}
<pre class="idl">
dictionary RTCEncodedAudioFrameMetadata : RTCEncodedFrameMetadata {
    short sequenceNumber;
    double audioLevel;
};
</pre>
### Members ### {#RTCEncodedAudioFrameMetadata-members}
<dl dfn-for="RTCEncodedAudioFrameMetadata" class="dictionary-members">
    <dt>
        <dfn dict-member>sequenceNumber</dfn> <span class=
            "idlMemberType">short</span>
    </dt>
    <dd>
        <p>
            The RTP sequence number as defined in [[RFC3550]]. Only exists for incoming audio frames.
        </p>
        <p class="note">
            Comparing two sequence numbers requires serial number arithmetic described in [[RFC1982]].
        </p>
    </dd>
    <dt>
        <dfn dict-member>audioLevel</dfn> <span class="idlMemberType">double</span>
    </dt>
    <dd>
        <p>
            The audio level of this frame. The value is between 0..1 (linear), 
            where 1.0 represents 0 dBov, 0 represents silence, and 0.5 represents
            approximately 6 dBSPL change in the sound pressure level from 0 dBov.

            If the frame comes from a remotely sourced track, this MUST be
            converted from the level value defined in [[!RFC6464]]. If the 
            [[!RFC6464]] header extension is not present in the received packets of the frame,
            this value MUST be absent.
            This RFC defines the audio level as an integral value from 0 to 127
            representing the audio level in negative decibels relative to the
            loudest signal that the system could possibly encode. Thus, 0
            represents the loudest signal the system could possibly encode,
            and 127 represents silence. To convert these values to the linear
            0..1 range, a value of 127 is converted to 0, and all other values
            are converted using the equation:
            <code class="math">10^(-rfc_level/20)</code>.

            If the frame comes from a locally sourced track, the level MUST be
            taken directly from the source and used as input to generate a value
            for the [[!RFC6464]] header extension, if negotiated.
        </p>
    </dd>
</dl>

## <dfn interface>RTCEncodedAudioFrame</dfn> interface ## {#RTCEncodedAudioFrame-interface}
<pre class="idl">
dictionary RTCEncodedAudioFrameOptions {
    RTCEncodedAudioFrameMetadata metadata;
};

[Exposed=(Window,DedicatedWorker), Serializable]
interface RTCEncodedAudioFrame {
    constructor(RTCEncodedAudioFrame originalFrame, optional RTCEncodedAudioFrameOptions options = {});
    attribute ArrayBuffer data;
    RTCEncodedAudioFrameMetadata getMetadata();
};
</pre>

### Constructor ### {#RTCEncodedAudioFrame-constructor}
<dl dfn-for="RTCEncodedAudioFrame" class="dictionary-members">
    <dt>
        <dfn for="RTCEncodedAudioFrame" method>constructor()</dfn>
    </dt>
    <dd>
        <p>
            Creates a new {{RTCEncodedAudioFrame}} from the given |originalFrame| and
            |options|.`[metadata]`. The newly created frame is completely independent of
            |originalFrame|, with its `[[data]]` being a deep copy of |originalFrame|.`[[data]]`.
            The new frame's `[[metadata]]` is a deep copy of |originalFrame|.`[[metadata]]`, with
            fields replaced with deep copies of the fields present in |options|.`[metadata]`.
        
            When called, run the following steps:

            1. Let this.`[[data]]` be the result of [[CloneArrayBuffer]](|originalFrame|.`[[data]]`, 0, |originalFrame|.`[[data]]`.`[[ArrayBufferByteLength]]`).
            1. Let `[[metadata]]` represent the metadata associated with this newly constructed frame.
                1. For each {`[[key]]`,`[[value]]`} pair of |originalFrame|.`[[getMetadata()]]`, set `[[metadata]]`.`[[key]]` to a deep copy of `[[value]]`.
                1. For each {`[[key]]`,`[[value]]`} pair of |options|.`[metadata]`, set `[[metadata]]`.`[[key]]` to a deep copy of `[[value]]`.

        </p>
    </dd>
</dl>

### Members ### {#RTCEncodedAudioFrame-members}
<dl dfn-for="RTCEncodedAudioFrame" class="dictionary-members">
    <dt>
        <dfn attribute>data</dfn> <span class="idlMemberType">ArrayBuffer</span>
    </dt>
    <dd>
        <p>
            The encoded frame data. The format of the data depends on the audio codec that is
            used to encode/decode the frame which can be determined by looking at the
            {{RTCEncodedFrameMetadata/mimeType}}.
            On getting, |this|.`[[data]]` MUST be returned. On setting, |this|.`[[data]]` MUST be set to the new value.
            The following table gives a number of examples:
        </p>
        <table class="simple">
            <thead>
                <tr>
                    <th>mimeType</th><th>Data format</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        audio/opus
                    </td>
                    <td>
                        The data is Opus packets, as described in
                        <a href="https://datatracker.ietf.org/doc/html/rfc6716#section-3">
                        section 3</a> of [[RFC6716]].
                    </td>
                </tr>
                <tr>
                    <td>
                        audio/PCMU
                    </td>
                    <td>
                        The data is a sequence of bytes of arbitrary length, where each byte is a u-law
                        encoded PCM sample as defined by Table 2a and 2b in [[ITU-G.711]].
                    </td>
                </tr>
                <tr>
                    <td>
                        audio/PCMA
                    </td>
                    <td>
                        The data is a sequence of bytes of arbitrary length, where each byte is
                        an A-law encoded PCM sample as defined by Tables 1a and 1b in [[ITU-G.711]].
                    </td>
                </tr>
                <tr>
                    <td>
                        audio/G722
                    </td>
                    <td>
                        The data is G.722 audio as described in [[ITU-G.722]].
                    </td>
                </tr>
                <tr>
                    <td>
                        audio/RED
                    </td>
                    <td>
                        The data is Redundant Audio Data as described in
                        <a href="https://www.rfc-editor.org/rfc/rfc2198#section-3">
                        section 3</a> of [[RFC2198]].
                    </td>
                </tr>
                <tr>
                    <td>
                        audio/CN
                    </td>
                    <td>
                        The data is Comfort Noise as described in
                        <a href="https://www.rfc-editor.org/rfc/rfc3389#section-3">
                        section 3</a> of [[RFC3389]].
                    </td>
                </tr>
            </tbody>
        </table>
    </dd>
</dl>

### Methods ### {#RTCEncodedAudioFrame-methods}
<dl dfn-for="RTCEncodedAudioFrame" class="dictionary-members">
    <dt>
        <dfn for="RTCEncodedAudioFrame" method>getMetadata()</dfn>
    </dt>
    <dd>
        <p>
            Returns the metadata associated with the frame.
        </p>
    </dd>
</dl>


### Serialization ### {#RTCEncodedAudioFrame-serialization}

{{RTCEncodedAudioFrame}} objects are [=serializable objects=].
Their [=serialization steps=], given |value|, |serialized|, and |forStorage|, are:

1. If |forStorage| is true, then throw a {{DataCloneError}}.
1. Set |serialized|.`[[metadata]]` to an internal representation of |value|'s metadata.
1. Set |serialized|.`[[data]]` to the [=sub-serialization=] of |value|.`[[data]]`.

Their [=deserialization steps=], given |serialized|, |value| and |realm|, are:

1. Set |value|'s metadata to the platform object representation of |serialized|.`[[metadata]]`
1. Set |value|.`[[data]]` to the [=sub-deserialization=] of |serialized|.`[[data]]`.


# <dfn interface>RTCRtpScriptTransform</dfn> interface # {#RTCRtpScriptTransform-interface}
<pre class="idl">
[Exposed=Window]
interface RTCRtpScriptTransform {
    constructor(Worker worker, optional any options, optional sequence&lt;object&gt; transfer);
};
</pre>

## Internal slots ## {#RTCRtpScriptTransform-internal-slots}

An {{RTCRtpScriptTransform}} object has the following internal slot:

<table class="data" dfn-for="RTCRtpScriptTransform" dfn-type="attribute">
 <thead>
  <tr>
   <th>Internal Slot
   <th>Description (<em>non-normative</em>)
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><dfn>`[[worker]]`</dfn>
   <td class="non-normative">The {{Worker}} provided in the constructor.
  </tr>
 </tbody>
</table>

## Constructor ## {#RTCRtpScriptTransform-constructor}

The <dfn constructor for="RTCRtpScriptTransform" lt="RTCRtpScriptTransform(worker, options)"><code>new RTCRtpScriptTransform(|worker|, |options|, |transfer|)</code></dfn> constructor steps are:
1. Initialize [=this=]'s internal slot as follows:
    : {{RTCRtpScriptTransform/[[worker]]}}
    :: |worker|
1. Let |serializedOptions| be the result of [$StructuredSerializeWithTransfer$](|options|, |transfer|).
1. [=Queue a global task=] on the DOM manipulation [=task source=] with |worker|'s
    {{WorkerGlobalScope}} to run the following steps:
    1. Let |transformerOptions| be the result of [$StructuredDeserializeWithTransfer$](|serializedOptions|, the current Realm).
    1. Let |transformer| be the result of [=RTCRtpScriptTransformer/creating=] a
        {{RTCRtpScriptTransformer}} with |transformerOptions|.
    1. [=Fire an event=] named <dfn event for="DedicatedWorkerGlobalScope">rtctransform</dfn> using {{RTCTransformEvent}} with {{RTCTransformEvent/transformer}} set to |transformer| on |transformer|’s [=relevant global object=].

// FIXME: Describe error handling (worker closing flag true at RTCRtpScriptTransform creation time. And worker being terminated while transform is processing data).

## Algorithms ## {#RTCRtpScriptTransform-algorithms}

Each {{RTCRtpScriptTransform}} has the following [$association algorithm$], given |rtcObject|:
1. Let |transform| be the {{RTCRtpScriptTransform}} object that owns the [$association algorithm$].
1. Let |frameSource| be |rtcObject|'s `[[frameSource]]`.
1. Let |workerGlobalScope| be |transform|.{{[[worker]]}}'s {{WorkerGlobalScope}}.
1. [=Queue a global task=] on the DOM manipulation [=task source=] with |workerGlobalScope|
     to run the following steps:
    1. Let |transformer| be the {{RTCRtpScriptTransformer}} object associated with |transform|.
    1. Set |transformer|.{{[[frameSource]]}} to |frameSource|.
1. [=In parallel=], set |frameSource|.[=[[transformFrameAlgorithm]]=] to the following steps,
    given an [=encoded frame=] |frame| as input:
    1. [=Queue a global task=] on the DOM manipulation [=task source=] with |workerGlobalScope|
        to run the following steps:
        1. Let |transformer| be the {{RTCRtpScriptTransformer}} object associated with |transform|.
        1. Let |jsFrame| be a new {{RTCEncodedVideoFrame}} from |frame| if |frame| is a video
            frame, or a new {{RTCEncodedAudioFrame}} from |frame| otherwise.
        1. Invoke [$readEncodedData$] with |transformer| and |jsFrame|.
    1. Wait for |frameSource|.[=[[processedFramesQueue]]=] to become non-empty.
    1. Return the result of [=dequeueing=] from |frameSource|.[=[[processedFramesQueue]]=].

Each {{RTCRtpScriptTransform}} has the following [$disassociation algorithm$]:
1. Let |transform| be the {{RTCRtpScriptTransform}} object that owns the [$disassociation algorithm$].
1. [=Queue a global task=] on the DOM manipulation [=task source=] with
    |transform|.{{[[worker]]}}'s {{WorkerGlobalScope}} to run the following steps:
    1. Let |transformer| be the {{RTCRtpScriptTransformer}} object associated with |transform|.
    1. [=ReadableStream/cancel=] |transformer|.{{[[readable]]}}.
    1. [=WritableStream/abort=] |transformer|.{{[[writable]]}}.

# <dfn interface>RTCRtpScriptTransformer</dfn> interface # {#RTCRtpScriptTransformer-interface}
<pre class="idl">
[Exposed=DedicatedWorker]
interface RTCRtpScriptTransformer : EventTarget {
    // Attributes and methods related to the transformer source
    readonly attribute ReadableStream readable;
    Promise&lt;undefined&gt; generateKeyFrame(optional DOMString rid);
    Promise&lt;undefined&gt; sendKeyFrameRequest();
    // Attributes and methods related to the transformer sink
    readonly attribute WritableStream writable;
    attribute EventHandler onkeyframerequest;
    // Attributes for configuring the Javascript code
    readonly attribute any options;
};
</pre>

## Internal slots ## {#RTCRtpScriptTransformer-internal-slots}

An {{RTCRtpScriptTransformer}} object has the following internal slots:

<table class="data" dfn-for="RTCRtpScriptTransformer" dfn-type="attribute">
 <thead>
  <tr>
   <th>Internal Slot
   <th>Description (<em>non-normative</em>)
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><dfn>`[[frameSource]]`</dfn>
   <td class="non-normative">An [=encoder=], a [=depacketizer=], or undefined.
  </tr>
  <tr>
   <td><dfn>`[[options]]`</dfn>
   <td class="non-normative">An optional {{Object}}, or null.
  </tr>
  <tr>
   <td><dfn>`[[readable]]`</dfn>
   <td class="non-normative">A {{ReadableStream}}.
  </tr>
  <tr>
   <td><dfn>`[[writable]]`</dfn>
   <td class="non-normative">A {{WritableStream}}.
  </tr>
  <tr>
   <td><dfn>`[[lastReceivedFrameCounter]]`</dfn>
   <td class="non-normative">A count of frames received.
  </tr>
  <tr>
   <td><dfn>`[[lastEnqueuedFrameCounter]]`</dfn>
   <td class="non-normative">A count of frames enqueued.
  </tr>
 </tbody>
</table>

<div algorithm="create|creating">
To <dfn for="RTCRtpScriptTransformer" lt="create|creating">create</dfn> an
{{RTCRtpScriptTransformer}}, given an |options| object, perform the following steps:
1. Let |transformer| be a [=new=] {{RTCRtpScriptTransformer}}, with:
    : {{RTCRtpScriptTransformer/[[frameSource]]}}
    :: undefined
    : {{RTCRtpScriptTransformer/[[options]]}}
    :: |options|
    : {{RTCRtpScriptTransformer/[[readable]]}}
    :: A new {{ReadableStream}}
    : {{RTCRtpScriptTransformer/[[writable]]}}
    :: A new {{WritableStream}}
    : {{RTCRtpScriptTransformer/[[lastReceivedFrameCounter]]}}
    :: 0
    : {{RTCRtpScriptTransformer/[[lastEnqueuedFrameCounter]]}}
    :: 0
1. [=ReadableStream/Set up=] |transformer|.{{[[readable]]}}. <p class="note">The
    [$readEncodedData$] algorithm, given |this| as parameter, provides encoded frames to it.
    </p>
1. Let |writeAlgorithm| be an action that runs [$writeEncodedData$] with |this| as
    parameter and |frame| as input, given |frame|.
1. [=WritableStream/Set up=] |transformer|.{{[[writable]]}} with its
    [=WritableStream/set up/writeAlgorithm=] set to |writeAlgorithm| and its [=WritableStream/set up/highWaterMark=] set to <code>Infinity</code>.
    <p class="note">highWaterMark is set to Infinity to explicitly disable backpressure.</p>
 1. Return |transformer|.

</div>

## Methods ## {#RTCRtpScriptTransformer-methods}

The <dfn method for="RTCRtpScriptTransformer">generateKeyFrame(|rid|)</dfn> method steps are:
1. Let |promise| be a new promise.
1. Run the [$generate key frame algorithm$] with |promise|, |this|.`[[frameSource]]` and |rid|.
1. Return |promise|.

The <dfn method for="RTCRtpScriptTransformer">sendKeyFrameRequest()</dfn> method steps are:
1. Let |promise| be a new promise.
1. Run the [$send request key frame algorithm$] with |promise| and |this|.`[[frameSource]]`.
1. Return |promise|.

## Attributes ## {#RTCRtpScriptTransformer-attributes}

The <dfn attribute for="RTCRtpScriptTransformer">options</dfn> getter steps are:
1. Return [=this=].`[[options]]`.

The <dfn attribute for="RTCRtpScriptTransformer">readable</dfn> getter steps are:
1. Return [=this=].`[[readable]]`.

The <dfn attribute for="RTCRtpScriptTransformer">writable</dfn> getter steps are:
1. Return [=this=].`[[writable]]`.

The <dfn attribute for="RTCRtpScriptTransformer">onbandwidthestimate</dfn> EventHandler has type bandwidthestimate.

The <dfn attribute for="RTCRtpScriptTransformer">onkeyframerequest</dfn> EventHandler has type keyframerequest.

## Events ## {#RTCRtpScriptTransformer-events}

<pre class="idl">
[Exposed=DedicatedWorker]
interface RTCTransformEvent : Event {
    readonly attribute RTCRtpScriptTransformer transformer;
};

partial interface DedicatedWorkerGlobalScope {
    attribute EventHandler onrtctransform;
};

[Exposed=DedicatedWorker]
interface KeyFrameRequestEvent : Event {
  constructor(DOMString type, optional DOMString rid);
  readonly attribute DOMString? rid;
};
</pre>

The following event fires on an {{RTCRtpScriptTransformer}}:

* keyframerequest of type {{KeyFrameRequestEvent}} - fired when the sink determines that a key frame has been requested.

The steps that generate an event of type {{KeyFrameRequestEvent}} are as follows:

When the [=encoder=] of an associated {{RTCRtpScriptTransformer}} |transformer| receives a keyframe request, for instance from an incoming RTCP Picture Loss Indication (PLI)
or Full Intra Refresh (FIR), queue a task to perform the following steps:

1. Set |rid| to the RID of the appropriate layer, or undefined if the request is not for a specific layer.
1. [=Fire an event=] named `keyframerequest` at |transformer| using {{KeyFrameRequestEvent}} with its {{Event/cancelable}} attribute initialized to "true", and with {{KeyFrameRequestEvent/rid}} set to |rid|.
1. If the event's [=Event/canceled flag=] is true, abort these steps.
1. Run the [$generate key frame algorithm$] with a new promise, |transformer|.`[[frameSource]]` and |rid|.

## KeyFrame Algorithms ## {#KeyFrame-algorithms}

The <dfn abstract-op>generate key frame algorithm</dfn>, given |promise|, |frameSource| and |rid|, is defined by running these steps:
1. If |frameSource| is not an [=encoder=], reject |promise| with {{InvalidStateError}}, abort these steps.
1. Let |encoder| be |frameSource|.
1. If |encoder| does not belong to a video {{RTCRtpSender}}, reject |promise| with {{InvalidStateError}}, abort these steps.
1. If |rid| is defined, but does not conform to the grammar requirements specified
    in Section 10 of [[!RFC8851]], then reject |promise| with {{TypeError}} and abort
    these steps.
1. [=In parallel=], run the following steps:
    1. Let |layers| be a new [=list=] of the layers for this |encoder|, ordered by negotiated encoding index.
    1. [=list/Remove=] from |layers| all layers that are not {{RTCRtpEncodingParameters/active}}, or whose
        corresponding {{RTCRtpSender}} track has ended.
    1. If |rid| is not undefined, [=list/remove=] from |layers| all layers whose RID is not |rid|.

       Note: If no |rid| is passed in, keyframes are generated for all active layers.

    1. If |layers| is now empty, [=queue a task=] to reject |promise| with {{NotFoundError}} and abort these steps.
    1. [=list/Remove=] from |layers| all layers already [=list/contained|found=] in any `[[layers]]` of any tasks in |encoder|.`[[pendingKeyFrameTasks]]`.
    1. Create a pending key frame task called |task| with |task|.`[[layers]]` set to |layers| and |task|.`[[promise]]` set to |promise|.
    1. If |encoder|.`[[pendingKeyFrameTasks]]` is undefined, initialize |encoder|.`[[pendingKeyFrameTasks]]` to an empty set.
    1. [=set/Append=] |task| to |encoder|.`[[pendingKeyFrameTasks]]`.
    1. For each |layer| in |layers| (if any), instruct |encoder| to generate a key frame for its
        next provided video frame to that |layer|.

For any [=encoder=] associated with an {{RTCRtpScriptTransformer}} |transformer|, the user agent MUST run the following steps just before any |frame| is [=ReadableStream/enqueued=] into |transformer|.{{[[readable]]}}:
1. Let |encoder| be |transformer|.{{[[frameSource]]}}.
1. If |encoder|.`[[pendingKeyFrameTasks]]` is undefined, abort these steps.
1. If |frame| is not a video {{RTCEncodedVideoFrameType/"key"}} frame, abort these steps.
1. For each |task| in |encoder|.`[[pendingKeyFrameTasks]]`, run the following steps:
    1. If |frame| was generated for a layer [=list/contained=] in |task|.`[[layers]]`,
        then run the following steps:
        1. [=list/Remove=] that layer from |task|.`[[layers]]`.
        1. If |task|.`[[layers]]` is now empty, then [=list/remove=] |task| from
            |encoder|.`[[pendingKeyFrameTasks]]`.
        1. [=Resolve=] |task|.`[[promise]]` with undefined.

By resolving the promises just before enqueuing the corresponding key frame in a {{RTCRtpScriptTransformer}}'s readable,
the resolution callbacks of the promises are always executed just before the corresponding key frame is exposed.
If the promise is associated with several layers, it will be resolved once key frames have been enqueued for all of them.

The <dfn abstract-op>send request key frame algorithm</dfn>, given |promise| and |frameSource|, is defined by running these steps:
1. If |frameSource| is not a [=depacketizer=], reject |promise| with {{InvalidStateError}}, abort these steps.
1. Let |depacketizer| be |frameSource|.
1. If |depacketizer| does not belong to a video {{RTCRtpReceiver}}, reject |promise| with {{InvalidStateError}}, abort these steps.
1. [=In parallel=], run the following steps:
    1. If sending a Full Intra Request (FIR) by |depacketizer|'s receiver is not deemed appropriate, [=resolve=] |promise| with undefined and abort these steps.
        Section 4.3.1 of [[RFC5104]] provides guidelines of how and when it is appropriate to sending a Full Intra Request.
    1. Generate a Full Intra Request (FIR) packet as defined in section 4.3.1 of [[RFC5104]] and send it through |depacketizer|'s receiver.
    1. [=Queue a task=] to [=resolve=] |promise| with undefined.

# Privacy and security considerations # {#privacy}

This API gives Javascript access to the content of media streams. This
is also available from other sources, such as Canvas and WebAudio.

However, streams that are isolated (as specified in
[[WEBRTC-IDENTITY]]) or tainted with another origin, cannot be
accessed using this API, since that would break the isolation rule.

The API will allow access to some aspects of timing information that are
otherwise unavailable, which allows some fingerprinting surface.

The API will give access to encoded media, which means that the JS application
will have full control over what's delivered to internal components like
the packetizer or the decoder. This may require additional care with
auditing how data is handled inside these components.

For instance, packetizers may expect to see data only from trusted encoders,
and may not be audited for reception of data from untrusted sources.

# Examples # {#examples}

See the [explainer document](https://github.com/w3c/webrtc-encoded-transform/blob/master/explainer.md#code-examples).
